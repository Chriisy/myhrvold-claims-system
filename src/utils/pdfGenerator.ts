import jsPDF from 'jspdf';
import QRCode from 'qrcode';

export interface ClaimData {
  id: string;
  claim_number: string;
  status: string;
  customer_name: string;
  customer_contact?: string;
  customer_email?: string;
  customer_phone?: string;
  customer_address?: string;
  product_name: string;
  product_model?: string;
  serial_number?: string;
  purchase_date?: string;
  warranty_period?: string;
  supplier: string;
  issue_description: string;
  detailed_description?: string;
  technician_name: string;
  work_hours?: number;
  hourly_rate?: number;
  travel_hours?: number;
  travel_distance_km?: number;
  vehicle_cost_per_km?: number;
  parts_cost?: number;
  consumables_cost?: number;
  external_services_cost?: number;
  total_cost?: number;
  expected_refund?: number;
  supplier_notes?: string;
  created_date: string;
  custom_line_items?: any[];
  po_reference?: string; // Added PO field
}

const translations = {
  no: {
    subject: 'Garantikrav - Krav om refusjon',
    greeting: 'Til',
    intro: 'Vi viser til garantiavtalen mellom våre bedrifter og ønsker herved å fremsette krav om refusjon for utført garantiarbeid.',
    claimInfo: 'Kravinformasjon',
    claimNumber: 'Kravinummer',
    claimId: 'Reklamasjonssak ID',
    claimDate: 'Kravdato',
    productInfo: 'Produktinformasjon',
    product: 'Produkt',
    model: 'Modell',
    serialNumber: 'Serienummer',
    purchaseDate: 'Kjøpsdato',
    warranty: 'Garantiperiode',
    reportedIssue: 'Registrert feil',
    serviceAction: 'Utført arbeid',
    technician: 'Tekniker',
    costBreakdown: 'Kostnadssammenbrudd',
    laborCosts: 'Arbeidskostnader',
    partsCosts: 'Delekostnader',
    travelCosts: 'Reisekostnader',
    totalCost: 'Totalkostnad',
    refundRequest: 'Refusjonskrav',
    requestedAction: 'Ønsket handling',
    defaultAction: 'Refusjon for defekt komponent under garanti',
    documentation: 'Dokumentasjon',
    docText: 'Alle relevante dokumenter, kvitteringer og bilder er vedlagt dette kravet.',
    resolution: 'Ønsket løsning',
    resolutionText: 'Vi krever full refusjon av kostnadene i henhold til garantiavtalen. Vi ber om svar innen 14 dager.',
    closing: 'Vi ser frem til en rask avklaring av denne saken.',
    regards: 'Med vennlig hilsen',
    companyName: 'Myhrvold Gruppen',
    footer: 'Dette dokumentet er sendt digitalt og krever ikke underskrift.',
    systemFooter: 'Dette dokumentet ble generert av: Myhrvold Claim System v1.0',
    year: 'år',
    partNumber: 'Artikkelnummer',
    description: 'Beskrivelse',
    quantity: 'Antall',
    sparePartsUsed: 'Artikler brukt',
    poReference: 'PO / Bestillingsreferanse',
    customerInfo: 'Kundeinformasjon',
    workPerformed: 'Utført arbeid',
    customer: 'Kunde'
  },
  en: {
    subject: 'Warranty Claim - Refund Request',
    greeting: 'To',
    intro: 'We refer to the warranty agreement between our companies and hereby submit a claim for refund of warranty work performed.',
    claimInfo: 'Claim Information',
    claimNumber: 'Claim Number',
    claimId: 'Claim ID',
    claimDate: 'Claim Date',
    productInfo: 'Product Information',
    product: 'Product',
    model: 'Model',
    serialNumber: 'Serial Number',
    purchaseDate: 'Purchase Date',
    warranty: 'Warranty Period',
    reportedIssue: 'Reported Issue',
    serviceAction: 'Service Action Taken',
    technician: 'Technician',
    costBreakdown: 'Cost Breakdown',
    laborCosts: 'Labor Costs',
    partsCosts: 'Parts Costs',
    travelCosts: 'Travel Costs',
    totalCost: 'Total Cost',
    refundRequest: 'Refund Request',
    requestedAction: 'Requested Action',
    defaultAction: 'Refund for faulty component under warranty',
    documentation: 'Documentation',
    docText: 'All relevant documents, receipts and images are attached to this claim.',
    resolution: 'Requested Resolution',
    resolutionText: 'We request full refund of the costs according to the warranty agreement. We ask for a response within 14 days.',
    closing: 'We look forward to a quick resolution of this matter.',
    regards: 'Best regards',
    companyName: 'Myhrvold Gruppen',
    footer: 'This document is sent digitally and does not require signature.',
    systemFooter: 'This document was generated by: Myhrvold Claim System v1.0',
    year: 'year',
    partNumber: 'Article Number',
    description: 'Description',
    quantity: 'Quantity',
    sparePartsUsed: 'Articles Used',
    poReference: 'PO / Purchase Order Reference',
    customerInfo: 'Customer Information',
    workPerformed: 'Work Performed',
    customer: 'Customer'
  }
};

const formatDate = (dateString: string | null | undefined, language: 'no' | 'en' = 'no') => {
  if (!dateString) return language === 'no' ? 'Ikke oppgitt' : 'Not specified';
  
  const date = new Date(dateString);
  const options: Intl.DateTimeFormatOptions = { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  };
  
  return date.toLocaleDateString(language === 'no' ? 'nb-NO' : 'en-GB', options);
};

const formatCurrency = (amount: number | null | undefined) => {
  if (!amount) return '0,00 kr';
  return new Intl.NumberFormat('nb-NO', {
    style: 'currency',
    currency: 'NOK'
  }).format(amount);
};

// Helper function to split text into multiple lines
const splitTextToLines = (doc: jsPDF, text: string, maxWidth: number) => {
  const words = text.split(' ');
  const lines: string[] = [];
  let currentLine = '';

  words.forEach(word => {
    const testLine = currentLine + (currentLine ? ' ' : '') + word;
    const lineWidth = doc.getTextWidth(testLine);
    
    if (lineWidth <= maxWidth) {
      currentLine = testLine;
    } else {
      if (currentLine) {
        lines.push(currentLine);
        currentLine = word;
      } else {
        lines.push(word);
      }
    }
  });
  
  if (currentLine) {
    lines.push(currentLine);
  }
  
  return lines;
};

export const generateClaimPDF = async (claim: ClaimData, language: 'no' | 'en', showFooter: boolean = true) => {
  const doc = new jsPDF('p', 'mm', 'a4');
  const t = translations[language];
  
  // Layout constants for consistent spacing and alignment
  const SECTION_GAP = 5;
  const LABEL_X = 20;
  const VALUE_X = 40; // Further reduced from 45 to 40 for tighter spacing
  const LINE_HEIGHT = 4;
  
  let yPosition = 20;

  // Clean header with company branding - reduced size
  doc.setFillColor(30, 41, 59);
  doc.rect(0, 0, 210, 30, 'F');
  
  // Company name - smaller for better proportion
  doc.setTextColor(255, 255, 255);
  doc.setFontSize(16);
  doc.setFont('helvetica', 'bold');
  doc.text(t.companyName, 20, 18);
  
  // Claim identifiers in top right with actual values
  const claimNumber = claim.claim_number || '(missing)';
  const claimId = claim.id || '(missing)';
  
  if (!claim.claim_number) {
    console.warn('Missing claim_number in PDF generation');
  }
  if (!claim.id) {
    console.warn('Missing claim.id in PDF generation');
  }
  
  // Claim ID (external)
  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.text(`${t.claimNumber}: `, 130, 15); // Added space after colon
  doc.setFont('helvetica', 'normal');
  doc.text(claimNumber, 150, 15); // Further reduced from 158 to 150
  
  // Reklamasjonssak ID (internal) - with proper text wrapping
  doc.setFontSize(9);
  doc.setFont('helvetica', 'bold');
  doc.text(`${t.claimId}: `, 130, 21); // Added space after colon
  doc.setFont('helvetica', 'normal');
  
  // Handle long claim IDs with proper wrapping
  const maxClaimIdWidth = 35; // Limited space in header
  if (doc.getTextWidth(claimId) > maxClaimIdWidth) {
    const claimIdLines = splitTextToLines(doc, claimId, maxClaimIdWidth);
    claimIdLines.forEach((line, index) => {
      doc.text(line, 150, 21 + (index * 3)); // Match reduced position
    });
  } else {
    doc.text(claimId, 150, 21); // Match reduced position
  }
  
  // Generated date
  doc.setFontSize(8);
  doc.setFont('helvetica', 'normal');
  doc.text(`Generated: ${new Date().toLocaleDateString(language === 'no' ? 'nb-NO' : 'en-GB')}`, 130, 26);

  // Document title - smaller and normalized
  doc.setTextColor(30, 41, 59);
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  yPosition = 40;
  doc.text(t.subject, 105, yPosition, { align: 'center' });
  
  // Subtle separator line
  doc.setDrawColor(203, 213, 225);
  doc.setLineWidth(0.3);
  doc.line(20, yPosition + 3, 190, yPosition + 3);

  yPosition += 12;

  // PO Reference field - added early in document
  if (claim.po_reference) {
    doc.setFontSize(10);
    doc.setFont('helvetica', 'bold');
    doc.text(`${t.poReference}:`, LABEL_X, yPosition);
    doc.setFont('helvetica', 'normal');
    
    // Handle long PO references with text wrapping
    const poText = claim.po_reference;
    const maxPoWidth = 120;
    if (doc.getTextWidth(poText) > maxPoWidth) {
      const poLines = splitTextToLines(doc, poText, maxPoWidth);
      poLines.forEach((line, index) => {
        doc.text(line, VALUE_X, yPosition + (index * LINE_HEIGHT));
      });
      yPosition += poLines.length * LINE_HEIGHT;
    } else {
      doc.text(poText, VALUE_X, yPosition);
      yPosition += LINE_HEIGHT;
    }
    yPosition += SECTION_GAP;
  }

  // Product Information section - normalized heading
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(30, 41, 59);
  doc.text(t.productInfo, LABEL_X, yPosition);
  yPosition += SECTION_GAP;

  // Product fields with consistent alignment
  doc.setFontSize(10);
  doc.setTextColor(30, 41, 59);
  
  doc.setFont('helvetica', 'bold');
  doc.text(`${t.product}:`, LABEL_X, yPosition);
  doc.setFont('helvetica', 'normal');
  
  // Handle brand name in bold with proper text wrapping
  const productName = claim.product_name;
  const maxProductWidth = 120;
  
  if (productName.includes('BIZERBA')) {
    const parts = productName.split('BIZERBA');
    let currentX = VALUE_X;
    
    if (parts[0]) {
      doc.text(parts[0], currentX, yPosition);
      currentX += doc.getTextWidth(parts[0]);
    }
    
    doc.setFont('helvetica', 'bold');
    doc.text('BIZERBA', currentX, yPosition);
    currentX += doc.getTextWidth('BIZERBA');
    
    doc.setFont('helvetica', 'normal');
    if (parts[1]) {
      doc.text(parts[1], currentX, yPosition);
    }
  } else if (doc.getTextWidth(productName) > maxProductWidth) {
    const productLines = splitTextToLines(doc, productName, maxProductWidth);
    productLines.forEach((line, index) => {
      doc.text(line, VALUE_X, yPosition + (index * LINE_HEIGHT));
    });
    yPosition += (productLines.length - 1) * LINE_HEIGHT;
  } else {
    doc.text(productName, VALUE_X, yPosition);
  }
  yPosition += LINE_HEIGHT;

  if (claim.product_model) {
    doc.setFont('helvetica', 'bold');
    doc.text(`${t.model}:`, LABEL_X, yPosition);
    doc.setFont('helvetica', 'normal');
    doc.text(claim.product_model, VALUE_X, yPosition);
    yPosition += LINE_HEIGHT;
  }

  if (claim.serial_number) {
    doc.setFont('helvetica', 'bold');
    doc.text(`${t.serialNumber}:`, LABEL_X, yPosition);
    doc.setFont('helvetica', 'normal');
    doc.text(claim.serial_number, VALUE_X, yPosition);
    yPosition += LINE_HEIGHT;
  }

  if (claim.purchase_date) {
    doc.setFont('helvetica', 'bold');
    doc.text(`${t.purchaseDate}:`, LABEL_X, yPosition);
    doc.setFont('helvetica', 'normal');
    doc.text(formatDate(claim.purchase_date, language), VALUE_X, yPosition);
    yPosition += LINE_HEIGHT;
  }

  if (claim.warranty_period) {
    doc.setFont('helvetica', 'bold');
    doc.text(`${t.warranty}:`, LABEL_X, yPosition);
    doc.setFont('helvetica', 'normal');
    // Fix the "1year" spacing issue
    let warrantyText = claim.warranty_period;
    if (!warrantyText.includes(' ')) {
      // Add space between number and year (e.g., "1year" -> "1 year")
      warrantyText = warrantyText.replace(/(\d+)(\w+)/, '$1 $2');
    }
    if (!warrantyText.includes(t.year)) {
      warrantyText += ` ${t.year}`;
    }
    doc.text(warrantyText, VALUE_X, yPosition);
    yPosition += LINE_HEIGHT;
  }

  yPosition += SECTION_GAP;

  // Reported Issue section - normalized heading and compact spacing
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text(t.reportedIssue, LABEL_X, yPosition);
  yPosition += SECTION_GAP;

  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  
  // Handle long issue descriptions with proper text wrapping
  const maxIssueWidth = 165;
  const issueLines = splitTextToLines(doc, claim.issue_description, maxIssueWidth);
  
  issueLines.forEach((line, index) => {
    doc.text(line, LABEL_X, yPosition + (index * LINE_HEIGHT));
  });
  yPosition += issueLines.length * LINE_HEIGHT;

  // Service Action Taken - tight grouping with issue
  yPosition += SECTION_GAP;
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text(t.serviceAction, LABEL_X, yPosition);
  yPosition += SECTION_GAP;

  if (claim.detailed_description) {
    doc.setFontSize(10);
    doc.setFont('helvetica', 'normal');
    
    // Clean up any formatting issues and improve readability
    let cleanDescription = claim.detailed_description
      .replace(/\s+/g, ' ') // Replace multiple spaces with single space
      .trim();
    
    // Improve specific text patterns
    if (language === 'en') {
      cleanDescription = cleanDescription
        .replace('Replaced the controller as it was not supplying power to the lower heating element. The unit was not programmed from the factory',
                'The temperature controller failed to supply power to the lower heating element. Investigation revealed the unit had not been properly initialized or configured at delivery. After replacing the controller, the unit operated as expected.');
    }
    
    const maxWidth = 165;
    const lines = splitTextToLines(doc, cleanDescription, maxWidth);
    
    lines.forEach(line => {
      doc.text(line, LABEL_X, yPosition);
      yPosition += LINE_HEIGHT;
    });
  }

  yPosition += SECTION_GAP;

  // Requested Action section - consistent with other sections
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text(t.requestedAction, LABEL_X, yPosition);
  yPosition += SECTION_GAP;

  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.text(t.defaultAction, LABEL_X, yPosition);
  yPosition += SECTION_GAP * 2; // Extra spacing after Requested Action

  // Customer Information - translated and consistent formatting
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text(t.customerInfo, LABEL_X, yPosition);
  yPosition += SECTION_GAP;

  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.text(`${t.customer}: `, LABEL_X, yPosition); // Added space after colon
  doc.setFont('helvetica', 'normal');
  doc.text(claim.customer_name, VALUE_X, yPosition); // Put on same line
  yPosition += SECTION_GAP;

  // Work Performed - grouped tightly with spare parts
  doc.setFontSize(14);
  doc.setFont('helvetica', 'bold');
  doc.text(t.workPerformed, LABEL_X, yPosition);
  yPosition += SECTION_GAP;

  doc.setFontSize(10);
  doc.setFont('helvetica', 'bold');
  doc.text(`${t.technician}: `, LABEL_X, yPosition); // Added space after colon
  doc.setFont('helvetica', 'normal');
  doc.text(claim.technician_name, VALUE_X, yPosition); // Put on same line  
  yPosition += LINE_HEIGHT;

  // Spare parts details (without prices) - improved layout
  const customLineItems = claim.custom_line_items ? 
    (Array.isArray(claim.custom_line_items) ? claim.custom_line_items : 
     (typeof claim.custom_line_items === 'string' ? JSON.parse(claim.custom_line_items) : [])) : [];
  
  if (customLineItems.length > 0) {
    yPosition += SECTION_GAP / 2;
    doc.setFont('helvetica', 'bold');
    doc.text(`${t.sparePartsUsed}:`, LABEL_X, yPosition);
    yPosition += SECTION_GAP;
    
    customLineItems.forEach((item: any, index: number) => {
      // Clean bullet point style for spare parts
      doc.setFont('helvetica', 'normal');
      doc.text('•', LABEL_X + 5, yPosition);
      doc.text(`${t.partNumber}: ${item.partNumber || 'N/A'}`, LABEL_X + 10, yPosition);
      yPosition += LINE_HEIGHT;
      
      doc.text('•', LABEL_X + 5, yPosition);
      doc.text(`${t.description}: ${item.description || 'N/A'}`, LABEL_X + 10, yPosition);  
      yPosition += LINE_HEIGHT;
      
      doc.text('•', LABEL_X + 5, yPosition);
      doc.text(`${t.quantity}: ${item.quantity || 1}`, LABEL_X + 10, yPosition);
      yPosition += SECTION_GAP; // Space between parts
    });
  }

  // Contact information for return correspondence - moved to bottom
  yPosition += SECTION_GAP * 2; // Extra space before contact info
  
  doc.setFontSize(10);
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(100, 100, 100);
  doc.text('Return correspondence to:', LABEL_X, yPosition);
  yPosition += LINE_HEIGHT;
  doc.setFont('helvetica', 'bold');
  doc.setTextColor(30, 41, 59);
  doc.text('Christopher Strøm', LABEL_X, yPosition);
  yPosition += LINE_HEIGHT;
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(100, 100, 100);
  doc.text('Technical Manager', LABEL_X, yPosition);
  yPosition += LINE_HEIGHT;
  doc.setFont('helvetica', 'normal');
  doc.setTextColor(30, 41, 59);
  doc.text('christopher.strom@myhrvold.no', LABEL_X, yPosition);
  yPosition += SECTION_GAP;

  // Optional footer section - controlled by showFooter flag
  if (showFooter) {
    yPosition += SECTION_GAP; // Space before footer if shown
    
    doc.setFontSize(8);
    doc.setTextColor(128, 128, 128);
    doc.text(`Claim Number: ${claim.claim_number}`, LABEL_X, yPosition);
    yPosition += LINE_HEIGHT;
    doc.text(`Generated: ${formatDate(new Date().toISOString(), language)}`, LABEL_X, yPosition);
    
    // QR code generation pointing to public view
    try {
      const publicUrl = `${window.location.origin}/public/claims/${claim.id}`;
      
      const qrCodeDataUrl = await QRCode.toDataURL(publicUrl, {
        width: 200,
        margin: 1,
        color: {
          dark: '#1e293b',
          light: '#ffffff'
        }
      });

      const qrSize = 20; // Smaller QR code
      const pageWidth = 210;
      const pageHeight = 297;
      const qrX = pageWidth - qrSize - 15;
      const qrY = pageHeight - qrSize - 15;

      doc.addImage(qrCodeDataUrl, 'PNG', qrX, qrY, qrSize, qrSize);

      doc.setFontSize(7);
      doc.setTextColor(100, 100, 100);
      const labelText = language === 'no' ? 'Scan for oppfølging' : 'Scan for follow-up';
      const labelWidth = doc.getTextWidth(labelText);
      doc.text(labelText, qrX + (qrSize - labelWidth) / 2, qrY + qrSize + 3);
    } catch (error) {
      console.error('Failed to generate QR code:', error);
    }
  }

  // Save the PDF
  const filename = language === 'no' 
    ? `garantikrav_${claim.claim_number}_NO.pdf`
    : `warranty_claim_${claim.claim_number}_EN.pdf`;
  doc.save(filename);
};